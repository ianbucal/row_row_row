import 'dart:io';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'extensions/string.extension.dart';

/// Maps database column types to Dart types, considering potential enums.
///
/// Converts a database [apiType] (derived from format/type in OpenAPI spec)
/// to its corresponding Dart type.
/// If the [property] map contains an 'enum' key, uses the database enum type name
/// or infers it if not explicitly provided.
/// If [isNullable] is true, the returned type will include a nullable suffix '?'.
///
/// Supported standard type mappings:
/// - 'uuid', 'text', 'varchar' → 'String'
/// - 'integer', 'int4', 'int8', 'bigint' → 'int'
/// - 'boolean' → 'bool'
/// - 'timestamp with time zone', 'timestamp without time zone', 'date', 'timestamptz' → 'DateTime'
/// - 'numeric', 'double precision', 'float4', 'float8' → 'double'
/// - 'json', 'jsonb' → 'dynamic'
/// - 'json[]', 'jsonb[]' → 'List<dynamic>'
/// - Any other type → 'dynamic'
String _mapType(
  String apiType,
  bool isNullable, {
  required String columnName,
  required Map<String, dynamic> property,
  Map<String, String>?
      enumTypeNames, // Map column names to their enum type names
}) {
  // Check for enum definition directly in the property
  print('property: $property');
  if (property.containsKey('enum') && property['enum'] is List) {
    // If we have a mapping for this column, use that enum name
    String enumName;
    if (enumTypeNames != null && enumTypeNames.containsKey(columnName)) {
      enumName = enumTypeNames[columnName]!;
    } else {
      // Fallback: Use the database type name if available, otherwise derive from column name
      final typeName = property['title'] as String? ??
          property['x-enum-name'] as String? ??
          property['x-pg-enum-name'] as String? ??
          (apiType == 'string' ? columnName : apiType).toPascalCase();
      print('typeName: $property');
      enumName = '${typeName.toPascalCase()}Enum';
    }
    return isNullable ? '$enumName?' : enumName;
  }

  // Standard type mapping
  final String baseType = switch (apiType) {
    'uuid' ||
    'text' ||
    'varchar' ||
    'character' ||
    'character varying' =>
      'String',
    'uuid[]' ||
    'text[]' ||
    'varchar[]' ||
    'character[]' ||
    'character varying[]' =>
      'List<String>',
    'integer' || 'int4' || 'int8' || 'bigint' || 'smallint' => 'int',
    'integer[]' ||
    'int4[]' ||
    'int8[]' ||
    'bigint[]' ||
    'smallint[]' =>
      'List<int>',
    'boolean' => 'bool',
    'boolean[]' => 'List<bool>',
    'timestamp with time zone' ||
    'timestamp without time zone' ||
    'date' ||
    'timestamptz' =>
      'DateTime',
    'time' => 'String', // Time as HH:MM:SS string
    'time[]' => 'List<String>', // Array of time strings
    'timestamp with time zone[]' ||
    'timestamp without time zone[]' ||
    'date[]' ||
    'timestamptz[]' =>
      'List<DateTime>',
    'numeric' || 'double precision' || 'float4' || 'float8' => 'double',
    'numeric[]' ||
    'double precision[]' ||
    'float4[]' ||
    'float8[]' =>
      'List<double>',
    'json' || 'jsonb' => 'dynamic',
    'json[]' || 'jsonb[]' => 'List<dynamic>',
    _ => 'dynamic', // Fallback for unknown types
  };
  if (baseType == 'dynamic') return 'dynamic';
  return isNullable ? '$baseType?' : baseType;
}

/// Generates the content for a Dart enum file based on OpenAPI spec values.
///
/// Takes an [enumName] (inferred PascalCase name) and a list of string [values].
/// Returns a Dart code string defining the enum with helper methods:
/// - `toValue`: Converts the enum member to its original string value.
/// - `fromValue`: Static method to parse a string into an enum member (throws error if invalid).
/// - `tryFromValue`: Static method to parse a string into an enum member (returns null if invalid).
String _generateEnumFile(String enumName, List<String> values) {
  final buffer = StringBuffer();
  buffer.writeln('// Generated by row_row_row tool');
  buffer.writeln('// Auto-generated file. Do not modify.');
  buffer.writeln();
  buffer.writeln('/// Represents the possible values for the $enumName enum.');
  buffer.writeln('enum $enumName {');

  // Generate enum values - attempt basic conversion for safety
  for (final value in values) {
    // Basic sanitization: convert to camelCase, replace non-alphanumeric with underscore
    final dartValue =
        value.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_').toCamelCase();
    buffer.writeln('  $dartValue,');
  }
  buffer.writeln('  ;'); // End of enum values
  buffer.writeln();

  // Generate toValue getter
  buffer.writeln(
    '  /// Converts enum to its string value for database interaction.',
  );
  buffer.writeln('  String get toValue => switch (this) {');
  for (final value in values) {
    // FIX: Apply the same sanitization logic here
    final dartValue =
        value.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_').toCamelCase();
    buffer.writeln('        $enumName.$dartValue => \'$value\',');
  }
  buffer.writeln('      };');
  buffer.writeln();

  // Generate fromValue static method
  buffer.writeln('  /// Creates an enum from a string value.');
  buffer.writeln('  /// Throws an ArgumentError if the [value] is not found.');
  buffer.writeln('  static $enumName fromValue(String value) {');
  buffer.writeln('    return $enumName.values.firstWhere(');
  buffer.writeln('      (e) => e.toValue == value,');
  buffer.writeln(
    '      orElse: () => throw ArgumentError("Invalid enum value: \$value for $enumName"),',
  );
  buffer.writeln('    );');
  buffer.writeln();

  // Generate tryFromValue static method
  buffer.writeln(
    '  /// Creates an enum from a string value, returning null if not found or if value is null.',
  );
  buffer.writeln('  static $enumName? tryFromValue(String? value) {');
  buffer.writeln('    if (value == null) return null;');
  buffer.writeln('    try {');
  buffer.writeln('      return fromValue(value);');
  buffer.writeln('    } catch (_) {');
  buffer.writeln('      return null;');
  buffer.writeln('    }');
  buffer.writeln('  }');

  buffer.writeln('}'); // Close enum definition
  return buffer.toString();
}

/// Detects if a definition represents a database view rather than a table.
///
/// Views are read-only and shouldn't have CRUD operations generated.
///
/// The definitive way to identify view vs table is through PostgreSQL's relkind value:
/// - 'r' = regular table (CRUD operations available)
/// - 'v' = view (read-only)
/// - 'm' = materialized view (read-only)
/// - 'f' = foreign table
///
/// This value comes from pg_class system catalog. In Supabase's OpenAPI spec,
/// it's exposed as x-pg-class.relkind extension property.
bool _isView(String tableName, Map<String, dynamic> definition) {
  print('Analyzing if "$tableName" is a view...');

  // DEFINITIVE METHOD: Check PostgreSQL relkind from pg_class
  if (definition.containsKey('x-pg-class')) {
    final pgClass = definition['x-pg-class'];

    if (pgClass is Map && pgClass.containsKey('relkind')) {
      final relkind = pgClass['relkind'];

      // Official PostgreSQL object type categorization
      if (relkind == 'v' || relkind == 'm') {
        print('  ✓ CONFIRMED VIEW: PostgreSQL relkind is "$relkind"');
        return true; // Definitely a view
      } else if (relkind == 'r') {
        print('  ✓ CONFIRMED TABLE: PostgreSQL relkind is "$relkind"');
        return false; // Definitely a table
      }

      print('  Found non-standard relkind value: "$relkind"');
    } else {
      print('  ⚠️ Found x-pg-class but no relkind property');
    }
  } else {
    print('  ⚠️ No x-pg-class metadata available, falling back to heuristics');
  }

  // When relkind is unavailable, fall back to secondary methods
  // This is less reliable and should be improved in future versions

  // Check for explicit view flag
  if (definition.containsKey('x-is-view') && definition['x-is-view'] == true) {
    print('  ✓ Detected as view: Has explicit x-is-view: true flag');
    return true;
  }

  // Check if the object has read-only permissions (views are read-only)
  if (definition.containsKey('x-pg-permissions')) {
    final permissions = definition['x-pg-permissions'];
    if (permissions is Map) {
      // If insert/update/delete capabilities are explicitly set to false, it's likely a view
      final isReadOnly = (permissions['insert'] == false &&
          permissions['update'] == false &&
          permissions['delete'] == false);

      if (isReadOnly) {
        print('  ✓ Detected as view: Has read-only permissions');
        return true;
      } else {
        // Has at least some write permissions
        print('  ✓ Detected as table: Has data modification permissions');
        return false;
      }
    }
  }

  // Check if table has primary keys (strong indicator of table vs view)
  bool hasPrimaryKey = _hasPrimaryKeys(definition);
  if (hasPrimaryKey) {
    print('  ✓ Detected as table: Has primary key(s) defined');
    return false; // Very likely a table, not a view
  }

  // Special case for specifically named tables we know to be views
  // These should ideally be identified by relkind, but this is a fallback
  final knownViews = [
    'NextOrderOfStatus',
    'NumberOfTasksPerProjectStatus',
    'NumberOfTasksPerProject',
    'ProcedureWithCategoryClinicAreaNames',
    'TaskClinicDepositSum',
    'TaskClinicRefundSum',
    'CustomerProcedureSubtotalView',
    'SubtaskAssigneeName',
    'ChatNumberOfUnseen',
    'ChatCategoryRoomRelation',
    'TaskAppointmentProcedureSummary',
    'DueDateTaskSubtaskAppointmentView',
    'TaskFromAsanaTempWithStatusAsignee',
    'AnnouncementTargetAudienceView',
    'AnnouncementWithTargetNames',
    'TaskAppointmentProcedureSummaryCsv',
  ];

  for (final viewName in knownViews) {
    if (tableName == viewName) {
      print('  ✓ Detected as view: Matches known view "$viewName"');
      return true;
    }
  }

  // Default to table if we couldn't determine otherwise
  print(
    '  ⚠️ Unable to definitively determine type, assuming it\'s a regular table',
  );
  return false;
}

/// Improved primary key detection for finding all primary key fields in a definition
///
/// Analyzes the [definition] and [properties] to find all fields that are part of the primary key.
/// Returns a list of maps containing:
/// - 'name': The original column name
/// - 'field_name': The camelCase field name
/// - 'property': The full property definition
List<Map<String, dynamic>> _findPrimaryKeyFields(
  Map<String, dynamic> definition,
  Map<String, dynamic> properties,
) {
  List<Map<String, dynamic>> primaryKeys = [];

  // Check for explicit primary keys in x-primary-keys array
  if (definition.containsKey('x-primary-keys') &&
      definition['x-primary-keys'] is List) {
    final keyNames = definition['x-primary-keys'] as List;
    print('  Found x-primary-keys: ${keyNames.join(', ')}');

    for (final keyName in keyNames) {
      if (properties.containsKey(keyName)) {
        primaryKeys.add({
          'name': keyName,
          'field_name': keyName.toString().toCamelCase(),
          'property': properties[keyName],
        });
      }
    }

    if (primaryKeys.isNotEmpty) {
      return primaryKeys;
    }
  }

  // Scan properties for primary key indicators
  for (final entry in properties.entries) {
    final columnName = entry.key;
    final property = entry.value;

    bool isPrimary = false;

    if (property is Map<String, dynamic>) {
      // Check for primary key metadata
      if ((property.containsKey('x-primary-key') &&
              property['x-primary-key'] == true) ||
          (property.containsKey('x-pk') && property['x-pk'] == true)) {
        isPrimary = true;
      }

      // Check if it's the typical 'id' field
      if (columnName == 'id') {
        isPrimary = true;
      }

      // Check description for primary key indicators
      final description = property['description'] as String? ?? '';
      if (description.toLowerCase().contains('primary key')) {
        isPrimary = true;
      }
    }

    if (isPrimary) {
      primaryKeys.add({
        'name': columnName,
        'field_name': columnName.toString().toCamelCase(),
        'property': property,
      });
    }
  }

  // If no primary keys were found, default to 'id' if it exists
  if (primaryKeys.isEmpty && properties.containsKey('id')) {
    primaryKeys.add({
      'name': 'id',
      'field_name': 'id',
      'property': properties['id'],
    });
  }

  return primaryKeys;
}

/// Helper to check if a definition contains primary keys
///
/// Checks both explicit primary key definitions and implicit ones (like 'id' field).
/// Returns true if any primary key is found.
bool _hasPrimaryKeys(Map<String, dynamic> definition) {
  // Check for primary key in properties
  if (definition.containsKey('properties')) {
    final properties = definition['properties'] as Map<String, dynamic>;
    for (final entry in properties.entries) {
      final property = entry.value;
      if (property is Map<String, dynamic>) {
        // Check for primary key indicators
        if (property.containsKey('x-primary-key') &&
            property['x-primary-key'] == true) {
          return true;
        }
      }
    }
  }

  // Check for primary key in x-primary-keys array
  if (definition.containsKey('x-primary-keys') &&
      definition['x-primary-keys'] is List) {
    final keys = definition['x-primary-keys'] as List;
    if (keys.isNotEmpty) {
      return true;
    }
  }

  return false;
}

/// Generates a Dart class for a database table.
///
/// Takes a [tableName], [properties] map containing column information,
/// and [requiredFields] list to determine which fields should be required.
/// The [enums] map contains information about discovered enums for import generation.
/// The [columnEnumMap] maps column names to their enum type names.
///
/// Returns a complete Dart class string that includes:
/// - A static 'field' record for mapping between Dart fields and DB columns
/// - Field declarations with proper Dart types (including generated Enums)
/// - A const constructor with required/optional parameters
/// - A fromJson factory constructor with proper type handling (including Enums)
/// - A toJson method (including Enums)
/// - CRUD methods for database operations (create, etc)
/// - Necessary import statements for generated enums.
///
/// The class follows naming conventions:
/// - Class name: `<PascalCaseTableName>Row`
/// - Field names: camelCase
String _generateRowClass(
  String tableName,
  Map<String, dynamic> properties,
  List<dynamic> requiredFields,
  Map<String, List<String>> enums, [
  // Pass the discovered enums map
  Map<String, String>?
      columnEnumMap, // Optional map of column names to enum types
  Map<String, dynamic>? definition, // Optional full definition of the table
]) {
  final baseName = tableName.toPascalCase();
  final className = '${baseName}Row';
  final buffer = StringBuffer();
  bool needsJsonDecodeImport = false;
  final Set<String> requiredEnumImports = {}; // Track required enum imports

  // Create a proper definition if none provided
  final effectiveDefinition = definition ??
      {'properties': properties, 'required': requiredFields, 'name': tableName};

  final classBuffer = StringBuffer();
  classBuffer.writeln('class $className {');

  // Adds a static field for the table name
  classBuffer.writeln('  static const table = \'$tableName\';');
  classBuffer.writeln();

  // Adds a static field for the field names
  classBuffer.writeln('  static const field = (');
  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      classBuffer.writeln('    $fieldName: \'$columnName\',');
    }
  });
  classBuffer.writeln('  );');
  classBuffer.writeln();

  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      final apiType = property['format'] ?? property['type'] ?? 'unknown';
      final isNullable = !requiredFields.contains(columnName);

      // Use column enum mapping if available
      final dartType = _mapType(
        apiType,
        isNullable,
        columnName: columnName,
        property: property,
        enumTypeNames: columnEnumMap,
      );

      // Check if it's an enum type to add import
      if (property.containsKey('enum') && property['enum'] is List) {
        // Get enum name from mapping if available, otherwise derive it
        String enumName;
        if (columnEnumMap != null && columnEnumMap.containsKey(columnName)) {
          enumName = columnEnumMap[columnName]!;
        } else {
          // Fallback to previous behavior
          final typeName = property['title'] as String? ??
              property['x-enum-name'] as String? ??
              property['x-pg-enum-name'] as String? ??
              (apiType == 'string' ? columnName : apiType).toPascalCase();
          enumName = '${typeName.toPascalCase()}Enum';
        }
        requiredEnumImports.add(enumName);
      }

      classBuffer.writeln('  final $dartType $fieldName;');
    }
  });
  classBuffer.writeln();

  classBuffer.writeln('  const $className({');
  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      final isNullable = !requiredFields.contains(columnName);

      if (!isNullable) {
        classBuffer.writeln('    required this.$fieldName,');
      } else {
        classBuffer.writeln('    this.$fieldName,');
      }
    }
  });
  classBuffer.writeln('  });');
  classBuffer.writeln();

  classBuffer.writeln(
    '  factory $className.fromJson(Map<String, dynamic> json) {',
  );
  classBuffer.writeln('    return $className(');
  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      final apiType = property['format'] ?? property['type'] ?? 'unknown';
      final isNullable = !requiredFields.contains(columnName);
      final dartType = _mapType(
        apiType,
        isNullable,
        columnName: columnName,
        property: property,
        enumTypeNames: columnEnumMap,
      );
      final jsonAccessor = 'json[field.$fieldName]';
      String parseLogic;

      // Check if it's an enum
      if (property.containsKey('enum') && property['enum'] is List) {
        // Get the enum name from mapping if available
        String enumName;
        if (columnEnumMap != null && columnEnumMap.containsKey(columnName)) {
          enumName = columnEnumMap[columnName]!;
        } else {
          // Fallback to previous behavior
          final typeName = property['title'] as String? ??
              property['x-enum-name'] as String? ??
              property['x-pg-enum-name'] as String? ??
              (apiType == 'string' ? columnName : apiType).toPascalCase();
          enumName = '${typeName.toPascalCase()}Enum';
        }

        if (isNullable) {
          parseLogic = '$enumName.tryFromValue($jsonAccessor as String?)';
        } else {
          parseLogic = '$enumName.fromValue($jsonAccessor as String)';
        }
      } else if (dartType.startsWith('DateTime')) {
        // Check if it's a timestamp with timezone that needs conversion
        final isTimestampWithZone =
            apiType == 'timestamp with time zone' || apiType == 'timestamptz';

        if (isNullable) {
          if (isTimestampWithZone) {
            // Convert to local time when reading from DB
            parseLogic =
                '$jsonAccessor == null ? null : DateTime.tryParse($jsonAccessor ?? \'\')?.toLocal()';
          } else {
            // Regular datetime without timezone conversion
            parseLogic =
                '$jsonAccessor == null ? null : DateTime.tryParse($jsonAccessor ?? \'\')';
          }
        } else {
          if (isTimestampWithZone) {
            // Convert to local time when reading from DB
            parseLogic = 'DateTime.parse($jsonAccessor).toLocal()';
          } else {
            // Regular datetime without timezone conversion
            parseLogic = 'DateTime.parse($jsonAccessor)';
          }
        }
      } else if (apiType == 'time') {
        // Handle SQL time type as a string (HH:MM:SS format)
        if (isNullable) {
          parseLogic = '$jsonAccessor as String?';
        } else {
          parseLogic = '$jsonAccessor as String';
        }
      } else if (dartType.startsWith('Map<String, dynamic>')) {
        needsJsonDecodeImport = true;
        if (isNullable) {
          parseLogic =
              '$jsonAccessor == null ? null : ($jsonAccessor is String ? jsonDecode($jsonAccessor) : Map<String, dynamic>.from($jsonAccessor))';
        } else {
          parseLogic =
              '$jsonAccessor is String ? jsonDecode($jsonAccessor) : Map<String, dynamic>.from($jsonAccessor)';
        }
      } else if (dartType.startsWith('Map<dynamic, dynamic>')) {
        needsJsonDecodeImport = true;
        if (isNullable) {
          parseLogic =
              '$jsonAccessor == null ? null : ($jsonAccessor is String ? jsonDecode($jsonAccessor) : Map.from($jsonAccessor))';
        } else {
          parseLogic =
              '$jsonAccessor is String ? jsonDecode($jsonAccessor) : Map.from($jsonAccessor)';
        }
      } else if (dartType.startsWith('List<String>')) {
        if (isNullable) {
          parseLogic =
              '$jsonAccessor == null ? null : List<String>.from($jsonAccessor)';
        } else {
          parseLogic = 'List<String>.from($jsonAccessor)';
        }
      } else if (dartType.startsWith('List<int>')) {
        if (isNullable) {
          parseLogic =
              '$jsonAccessor == null ? null : List<int>.from($jsonAccessor.map((x) => x is String ? int.parse(x) : x is num ? x.toInt() : x))';
        } else {
          parseLogic =
              'List<int>.from($jsonAccessor.map((x) => x is String ? int.parse(x) : x is num ? x.toInt() : x))';
        }
      } else if (dartType.startsWith('List<double>')) {
        if (isNullable) {
          parseLogic =
              '$jsonAccessor == null ? null : List<double>.from($jsonAccessor.map((x) => x is String ? double.parse(x) : x is num ? x.toDouble() : x))';
        } else {
          parseLogic =
              'List<double>.from($jsonAccessor.map((x) => x is String ? double.parse(x) : x is num ? x.toDouble() : x))';
        }
      } else if (dartType.startsWith('List<Map>')) {
        needsJsonDecodeImport = true;
        if (isNullable) {
          parseLogic =
              '$jsonAccessor == null ? null : List<Map>.from($jsonAccessor.map((x) => x is String ? jsonDecode(x) : Map.from(x)))';
        } else {
          parseLogic =
              'List<Map>.from($jsonAccessor.map((x) => x is String ? jsonDecode(x) : Map.from(x)))';
        }
      } else if (dartType == 'double') {
        parseLogic =
            '$jsonAccessor == null ? 0.0 : ($jsonAccessor as num).toDouble()';
        if (!isNullable) {
          parseLogic = '($jsonAccessor as num).toDouble()';
        } else {
          parseLogic =
              '$jsonAccessor == null ? null : ($jsonAccessor as num?)?.toDouble()';
        }
      } else if (dartType == 'double?') {
        parseLogic =
            '$jsonAccessor == null ? null : ($jsonAccessor as num?)?.toDouble()';
      } else if (dartType == 'int') {
        parseLogic =
            '$jsonAccessor == null ? 0 : ($jsonAccessor as num).toInt()';
        if (!isNullable) {
          parseLogic = '($jsonAccessor as num).toInt()';
        } else {
          parseLogic =
              '$jsonAccessor == null ? null : ($jsonAccessor as num?)?.toInt()';
        }
      } else if (dartType == 'int?') {
        parseLogic =
            '$jsonAccessor == null ? null : ($jsonAccessor as num?)?.toInt()';
      } else {
        parseLogic = jsonAccessor;
        if (!isNullable && dartType != 'dynamic') {
          parseLogic += ' as $dartType';
        }
      }
      classBuffer.writeln('      $fieldName: $parseLogic,');
    }
  });
  classBuffer.writeln('    );');
  classBuffer.writeln('  }');
  classBuffer.writeln('');

  classBuffer.writeln('  Map<String, dynamic> toJson() {');
  classBuffer.writeln('    return {');
  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      final apiType = property['format'] ?? property['type'] ?? 'unknown';
      final isNullable = !requiredFields.contains(columnName);
      final dartType = _mapType(
        apiType,
        isNullable,
        columnName: columnName,
        property: property,
        enumTypeNames: columnEnumMap,
      );

      String valueAccessor = fieldName;

      // Check if it's an enum
      if (property.containsKey('enum') && property['enum'] is List) {
        if (isNullable) {
          valueAccessor = '$fieldName?.toValue';
        } else {
          valueAccessor = '$fieldName.toValue';
        }
      } else if (dartType.startsWith('DateTime')) {
        // Check if it's a timestamp with timezone that needs conversion
        final isTimestampWithZone =
            apiType == 'timestamp with time zone' || apiType == 'timestamptz';

        if (isNullable) {
          if (isTimestampWithZone) {
            // Convert to UTC when writing to DB
            valueAccessor = '$fieldName?.toUtc().toIso8601String()';
          } else {
            // Regular datetime without timezone conversion
            valueAccessor = '$fieldName?.toIso8601String()';
          }
        } else {
          if (isTimestampWithZone) {
            // Convert to UTC when writing to DB
            valueAccessor = '$fieldName.toUtc().toIso8601String()';
          } else {
            // Regular datetime without timezone conversion
            valueAccessor = '$fieldName.toIso8601String()';
          }
        }
      } else if (apiType == 'time') {
        // Time is already a string in HH:MM:SS format, so we can pass it directly
        valueAccessor = fieldName;
      }
      // other types serialize directly
      classBuffer.writeln('      field.$fieldName: $valueAccessor,');
    }
  });
  classBuffer.writeln('    };');
  classBuffer.writeln('  }');

  // Add copyWith method
  classBuffer.writeln();
  classBuffer.writeln('  $className copyWith({');
  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      final apiType = property['format'] ?? property['type'] ?? 'unknown';
      final isNullable = !requiredFields.contains(columnName);
      final dartType = _mapType(
        apiType,
        isNullable,
        columnName: columnName,
        property: property,
        enumTypeNames: columnEnumMap,
      );

      // If the type is already nullable (ends with ?), don't add another ?

      if (dartType.endsWith('?') || dartType == 'dynamic') {
        classBuffer.writeln('    $dartType $fieldName,');
      } else {
        classBuffer.writeln('    $dartType? $fieldName,');
      }
    }
  });
  classBuffer.writeln('  }) {');
  classBuffer.writeln('    return $className(');
  properties.forEach((columnName, property) {
    if (property is Map<String, dynamic>) {
      final fieldName = columnName.toCamelCase();
      classBuffer.writeln('      $fieldName: $fieldName ?? this.$fieldName,');
    }
  });
  classBuffer.writeln('    );');
  classBuffer.writeln('  }');

  // Check if this is a view - if it is, don't add CRUD methods
  final bool isView = _isView(tableName, effectiveDefinition);

  // Add diagnostic logging for better debugging
  if (isView) {
    print('⚠️ $tableName detected as a view - SKIPPING CRUD methods');
    print('  Definition keys: ${effectiveDefinition.keys.join(', ')}');

    // Add a comment in the generated class to indicate it's a view
    classBuffer.writeln();
    classBuffer.writeln('  // This is detected as a database VIEW.');
    classBuffer.writeln('  // CRUD operations are not available for views.');
    classBuffer.writeln('  // Views are read-only objects in the database.');
  } else {
    print('✅ $tableName detected as a table - ADDING CRUD methods');
    print('  Definition keys: ${effectiveDefinition.keys.join(', ')}');

    // Print 'x-' prefixed keys to check for view/table indicators
    final xKeys =
        effectiveDefinition.keys.where((k) => k.startsWith('x-')).toList();
    if (xKeys.isNotEmpty) {
      print('  x- prefixed keys: ${xKeys.join(', ')}');
    }

    // Only add CRUD methods if not a view - strict enforcement
    // Add create method only for tables, not for views
    classBuffer.writeln();
    classBuffer.writeln('  /// Creates a new row in the database.');
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// Only non-null fields will be included in the insert payload.',
    );
    classBuffer.writeln(
      '  /// Primary keys and auto-generated fields can be set manually or left null for database defaults.',
    );
    classBuffer.writeln(
      '  /// Returns the created row with any auto-generated values.',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// Requires [supabase_flutter] package to be installed and initialized.',
    );

    // Create a new method that takes nullable parameters for all fields
    classBuffer.writeln('  static Future<$className> create({');

    // Add nullable parameters for all fields
    properties.forEach((columnName, property) {
      if (property is Map<String, dynamic>) {
        final fieldName = columnName.toCamelCase();
        final apiType = property['format'] ?? property['type'] ?? 'unknown';

        // Get the base type without the nullable modifier
        final dartType = _mapType(
          apiType,
          true, // Force nullable for all parameters
          columnName: columnName,
          property: property,
          enumTypeNames: columnEnumMap,
        );

        classBuffer.writeln('    $dartType $fieldName,');
      }
    });

    classBuffer.writeln('  }) async {');

    // Create the insert payload directly from parameters using collection if syntax
    classBuffer.writeln(
      '    // Build the insert payload with only non-null fields using collection if',
    );
    classBuffer.writeln('    final Map<String, dynamic> insertPayload = {');

    // Add each field with collection if syntax
    properties.forEach((columnName, property) {
      if (property is Map<String, dynamic>) {
        final fieldName = columnName.toCamelCase();
        final apiType = property['format'] ?? property['type'] ?? 'unknown';

        // Handle special conversions for different types
        if (apiType == 'timestamp with time zone' || apiType == 'timestamptz') {
          // Convert to UTC for timestamp with timezone
          classBuffer.writeln(
            '      if ($fieldName != null) field.$fieldName: $fieldName.toUtc().toIso8601String(),',
          );
        } else if (apiType.startsWith('timestamp') || apiType == 'date') {
          // Regular timestamp/date conversion
          classBuffer.writeln(
            '      if ($fieldName != null) field.$fieldName: $fieldName.toIso8601String(),',
          );
        } else if (property.containsKey('enum') && property['enum'] is List) {
          // Handle enum conversion
          classBuffer.writeln(
            '      if ($fieldName != null) field.$fieldName: $fieldName.toValue,',
          );
        } else {
          // Normal field
          classBuffer.writeln(
            '      if ($fieldName != null) field.$fieldName: $fieldName,',
          );
        }
      }
    });

    classBuffer.writeln('    };');

    classBuffer.writeln('');
    classBuffer.writeln('    final response = await Supabase.instance.client');
    classBuffer.writeln('        .from(table)');
    classBuffer.writeln('        .insert(insertPayload)');
    classBuffer.writeln('        .select()');
    classBuffer.writeln('        .single();');
    classBuffer.writeln('    return $className.fromJson(response);');
    classBuffer.writeln('  }');
  }

  // Find the primary key fields
  final primaryKeyFields = _findPrimaryKeyFields(
    effectiveDefinition,
    properties,
  );

  // Generate getter methods for all fields
  for (final entry in properties.entries) {
    final columnName = entry.key;
    final property = entry.value as Map<String, dynamic>;
    final fieldName = columnName.toCamelCase();
    final apiType = property['format'] ?? property['type'] ?? 'unknown';

    // Skip if this is a primary key field (it will be handled separately)
    bool isPrimaryKey = primaryKeyFields.any((pk) => pk['name'] == columnName);
    if (isPrimaryKey) continue;

    // Generate parameter with proper type
    String paramType;
    if (apiType == 'integer' ||
        apiType == 'int4' ||
        apiType == 'int8' ||
        apiType == 'bigint') {
      paramType = 'int';
    } else if (apiType == 'uuid') {
      paramType = 'String';
    } else {
      paramType = _mapType(
        apiType,
        false, // Parameters for getters are not nullable
        columnName: columnName,
        property: property,
        enumTypeNames: columnEnumMap,
      );
    }

    // Determine default orderBy value and type
    String orderByParam;
    bool isOrderByNullable;
    if (properties.containsKey('updated_at')) {
      orderByParam = 'String orderBy = "updated_at"';
      isOrderByNullable = false;
    } else if (properties.containsKey('created_at')) {
      orderByParam = 'String orderBy = "created_at"';
      isOrderByNullable = false;
    } else {
      orderByParam = 'String? orderBy';
      isOrderByNullable = true;
    }

    // Add method documentation
    classBuffer.writeln();
    classBuffer.writeln(
      '  /// Retrieves a single row from the database by $fieldName.',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// Returns the row if found, or throws an error if not found.',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// [orderBy] specifies which field to sort by. If not provided, defaults to:',
    );
    classBuffer.writeln('  /// - "updated_at" if the field exists');
    classBuffer.writeln('  /// - "created_at" if the field exists');
    classBuffer.writeln('  /// - No default ordering if neither field exists');
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// [orderAsc] determines the sort order. Defaults to false (descending).',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// Requires [supabase_flutter] package to be installed and initialized.',
    );

    // Generate the getter method
    final methodName =
        'retrieveBy${fieldName[0].toUpperCase()}${fieldName.substring(1)}';
    classBuffer.writeln('  static Future<$className> $methodName(');
    classBuffer.writeln('    $paramType $fieldName, {');
    classBuffer.writeln('    $orderByParam,');
    classBuffer.writeln('    bool orderAsc = false,');
    classBuffer.writeln('  }) async {');
    classBuffer.writeln('    final query = Supabase.instance.client');
    classBuffer.writeln('        .from(table)');
    classBuffer.writeln('        .select()');
    classBuffer.writeln('        .eq(field.$fieldName, $fieldName);');
    classBuffer.writeln();
    classBuffer.writeln('    // Apply ordering if specified');
    if (isOrderByNullable) {
      classBuffer.writeln('    if (orderBy != null) {');
      classBuffer.writeln('      query.order(orderBy, ascending: orderAsc);');
      classBuffer.writeln('    }');
    } else {
      classBuffer.writeln('    query.order(orderBy, ascending: orderAsc);');
    }
    classBuffer.writeln();
    classBuffer.writeln('    final response = await query.single();');
    classBuffer.writeln('    return $className.fromJson(response);');
    classBuffer.writeln('  }');

    // Add range-based retrieval for numeric and date fields
    if (apiType == 'integer' ||
        apiType == 'int4' ||
        apiType == 'int8' ||
        apiType == 'bigint' ||
        apiType == 'numeric' ||
        apiType == 'double precision' ||
        apiType == 'float4' ||
        apiType == 'float8' ||
        apiType == 'timestamp with time zone' ||
        apiType == 'timestamp without time zone' ||
        apiType == 'date' ||
        apiType == 'timestamptz') {
      // Add range method documentation
      classBuffer.writeln();
      classBuffer.writeln(
        '  /// Retrieves rows from the database where $fieldName is within the specified range.',
      );
      classBuffer.writeln('  /// ');
      classBuffer.writeln(
        '  /// Returns a list of rows matching the range criteria.',
      );
      classBuffer.writeln('  /// ');
      classBuffer.writeln(
        '  /// Range parameters are optional. If none are provided, all rows will be returned.',
      );
      classBuffer.writeln('  /// ');
      classBuffer.writeln(
        '  /// [orderBy] specifies which field to sort by. If not provided, defaults to:',
      );
      classBuffer.writeln('  /// - "updated_at" if the field exists');
      classBuffer.writeln('  /// - "created_at" if the field exists');
      classBuffer.writeln(
        '  /// - No default ordering if neither field exists',
      );
      classBuffer.writeln('  /// ');
      classBuffer.writeln(
        '  /// [orderAsc] determines the sort order. Defaults to false (descending).',
      );
      classBuffer.writeln('  /// ');
      classBuffer.writeln(
        '  /// Requires [supabase_flutter] package to be installed and initialized.',
      );

      // Generate the range method
      final rangeMethodName =
          'retrieve${fieldName[0].toUpperCase()}${fieldName.substring(1)}ByRange';
      classBuffer.writeln(
        '  static Future<List<$className>> $rangeMethodName({',
      );
      classBuffer.writeln('    $paramType? lessThan,');
      classBuffer.writeln('    $paramType? greaterThan,');
      classBuffer.writeln('    $paramType? lessThanOrEqual,');
      classBuffer.writeln('    $paramType? greaterThanOrEqual,');
      classBuffer.writeln('    $orderByParam,');
      classBuffer.writeln('    bool orderAsc = false,');
      classBuffer.writeln('  }) async {');
      classBuffer.writeln('    final query = Supabase.instance.client');
      classBuffer.writeln('        .from(table)');
      classBuffer.writeln('        .select();');
      classBuffer.writeln();
      classBuffer.writeln('    // Apply range conditions');
      classBuffer.writeln('    if (lessThan != null) {');
      classBuffer.writeln('      query.lt(field.$fieldName, lessThan);');
      classBuffer.writeln('    }');
      classBuffer.writeln('    if (greaterThan != null) {');
      classBuffer.writeln('      query.gt(field.$fieldName, greaterThan);');
      classBuffer.writeln('    }');
      classBuffer.writeln('    if (lessThanOrEqual != null) {');
      classBuffer.writeln(
        '      query.lte(field.$fieldName, lessThanOrEqual);',
      );
      classBuffer.writeln('    }');
      classBuffer.writeln('    if (greaterThanOrEqual != null) {');
      classBuffer.writeln(
        '      query.gte(field.$fieldName, greaterThanOrEqual);',
      );
      classBuffer.writeln('    }');

      // Add ordering
      classBuffer.writeln();
      classBuffer.writeln('    // Apply ordering if specified');
      if (isOrderByNullable) {
        classBuffer.writeln('    if (orderBy != null) {');
        classBuffer.writeln('      query.order(orderBy, ascending: orderAsc);');
        classBuffer.writeln('    }');
      } else {
        classBuffer.writeln('    query.order(orderBy, ascending: orderAsc);');
      }

      // Return the results
      classBuffer.writeln();
      classBuffer.writeln('    final response = await query;');
      classBuffer.writeln(
        '    return response.map((json) => $className.fromJson(json)).toList();',
      );
      classBuffer.writeln('  }');
    }
  }

  // Handle primary key getters
  if (primaryKeyFields.isNotEmpty) {
    // Determine default orderBy value and type
    String orderByParam;
    bool isOrderByNullable;
    if (properties.containsKey('updated_at')) {
      orderByParam = 'String orderBy = "updated_at"';
      isOrderByNullable = false;
    } else if (properties.containsKey('created_at')) {
      orderByParam = 'String orderBy = "created_at"';
      isOrderByNullable = false;
    } else {
      orderByParam = 'String? orderBy';
      isOrderByNullable = true;
    }

    // Add method documentation
    classBuffer.writeln();
    classBuffer.writeln(
      '  /// Retrieves a single row from the database by its primary key.',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// Returns the row if found, or throws an error if not found.',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// [orderBy] specifies which field to sort by. If not provided, defaults to:',
    );
    classBuffer.writeln('  /// - "updated_at" if the field exists');
    classBuffer.writeln('  /// - "created_at" if the field exists');
    classBuffer.writeln('  /// - No default ordering if neither field exists');
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// [orderAsc] determines the sort order. Defaults to false (descending).',
    );
    classBuffer.writeln('  /// ');
    classBuffer.writeln(
      '  /// Requires [supabase_flutter] package to be installed and initialized.',
    );

    // Create method name based on primary key fields
    String methodName = 'retrieveFrom';
    List<String> parameters = [];
    List<String> conditions = [];

    if (primaryKeyFields.length == 1) {
      // For single primary key, use the field name directly
      final pkField = primaryKeyFields[0];
      final fieldName = pkField['field_name'] as String;
      final property = pkField['property'] as Map<String, dynamic>;
      final originalName = pkField['name'] as String;

      // Capitalize first letter for method name
      methodName += fieldName[0].toUpperCase() + fieldName.substring(1);

      // Generate parameter with proper type
      final apiType = property['format'] ?? property['type'] ?? 'unknown';
      String paramType;

      if (apiType == 'integer' ||
          apiType == 'int4' ||
          apiType == 'int8' ||
          apiType == 'bigint') {
        paramType = 'int';
      } else if (apiType == 'uuid') {
        paramType = 'String';
      } else {
        paramType = _mapType(
          apiType,
          false, // Primary keys are usually not nullable
          columnName: originalName,
          property: property,
          enumTypeNames: columnEnumMap,
        );
      }

      parameters.add('$paramType $fieldName');
      conditions.add('field.$fieldName, $fieldName');
    } else {
      // For composite keys, create a more descriptive method name
      methodName = 'retrieveFromComposite';
      for (final pkField in primaryKeyFields) {
        final fieldName = pkField['field_name'] as String;
        final property = pkField['property'] as Map<String, dynamic>;
        final originalName = pkField['name'] as String;

        // Add to method name
        methodName += fieldName[0].toUpperCase() + fieldName.substring(1);

        // Generate parameter with proper type
        final apiType = property['format'] ?? property['type'] ?? 'unknown';
        String paramType;

        if (apiType == 'integer' ||
            apiType == 'int4' ||
            apiType == 'int8' ||
            apiType == 'bigint') {
          paramType = 'int';
        } else if (apiType == 'uuid') {
          paramType = 'String';
        } else {
          paramType = _mapType(
            apiType,
            false,
            columnName: originalName,
            property: property,
            enumTypeNames: columnEnumMap,
          );
        }

        parameters.add('$paramType $fieldName');
        conditions.add('field.$fieldName, $fieldName');
      }
    }

    // Log the generated method name and parameters
    print('  Generated fetch method: $methodName(${parameters.join(', ')})');

    classBuffer.writeln('  static Future<$className> $methodName(');
    classBuffer.writeln('    ${parameters.join(', ')}, {');
    classBuffer.writeln('    $orderByParam,');
    classBuffer.writeln('    bool orderAsc = false,');
    classBuffer.writeln('  }) async {');
    classBuffer.writeln('    final query = Supabase.instance.client');
    classBuffer.writeln('        .from(table)');
    classBuffer.writeln('        .select()');

    // Add condition for each primary key
    for (final condition in conditions) {
      classBuffer.writeln('        .eq($condition)');
    }
    classBuffer.writeln(';');
    classBuffer.writeln();
    classBuffer.writeln('    // Apply ordering if specified');
    if (isOrderByNullable) {
      classBuffer.writeln('    if (orderBy != null) {');
      classBuffer.writeln('      query.order(orderBy, ascending: orderAsc);');
      classBuffer.writeln('    }');
    } else {
      classBuffer.writeln('    query.order(orderBy, ascending: orderAsc);');
    }
    classBuffer.writeln();
    classBuffer.writeln('    final response = await query.single();');
    classBuffer.writeln('    return $className.fromJson(response);');
    classBuffer.writeln('  }');
  } else {
    print(
      '  ⚠️ No primary keys found for $tableName, skipping retrieveFrom method',
    );
  }

  classBuffer.writeln('}');

  // Add header comments and imports
  buffer.writeln('// Generated by row_row_row tool');
  buffer.writeln('// Auto-generated file. Do not modify.');
  if (needsJsonDecodeImport) {
    buffer.writeln("import 'dart:convert';");
  }
  buffer.writeln("import 'package:supabase_flutter/supabase_flutter.dart';");
  // Add required enum imports
  for (final enumName in requiredEnumImports) {
    // Strip 'Enum' suffix if present to avoid redundancy in file naming
    final enumBaseName = enumName.endsWith('Enum')
        ? enumName.substring(0, enumName.length - 4)
        : enumName;

    buffer.writeln(
      "import '../enums/${enumBaseName.toSnakeCase()}.enum.dart';",
    ); // Use snake_case for file name convention
  }
  if (needsJsonDecodeImport || requiredEnumImports.isNotEmpty) {
    buffer.writeln(); // Add a newline after imports
  }

  buffer.write(classBuffer.toString());

  return buffer.toString();
}

/// Deletes all files in a directory (but keeps the directory)
///
/// Used to clean up generated files before regenerating them.
/// Recursively deletes all files and subdirectories in [directory].
Future<void> _cleanDirectory(Directory directory) async {
  if (await directory.exists()) {
    final entities = await directory.list().toList();
    for (final entity in entities) {
      if (entity is File) {
        await entity.delete();
      } else if (entity is Directory) {
        await entity.delete(recursive: true);
      }
    }
    print('Cleaned directory: ${directory.path}');
  }
}

/// Main function to generate Dart model classes and enums for Supabase tables.
///
/// Connects to a Supabase project using [supabaseUrl] and [serviceRoleKey],
/// then fetches the database schema via the OpenAPI specification.
///
/// For each table in the schema:
/// - Analyzes column types and constraints.
/// - Detects columns using enums based on the 'enum' keyword in the spec.
/// - Generates a corresponding Dart class (`<TableName>Row`) with appropriate types.
/// - Creates a file named `<tableName>.row.dart` in `lib/row_row_row/tables/`.
///
/// For each discovered enum type:
/// - Generates a Dart enum file based on the database enum type name
/// - Includes helper methods for serialization/deserialization.
///
/// Additionally, generates a schema report file.
/// If [formatCode] is true, runs `dart format` on the generated files.
/// If [clean] is true, deletes all existing generated files before generating new ones.
///
/// Requires a properly configured Supabase project.
Future<void> generate({
  required String supabaseUrl,
  required String serviceRoleKey,
  required bool formatCode,
  bool clean = false,
}) async {
  final Uri uri = Uri.parse(supabaseUrl);
  final String projectId = uri.host.split('.').first;
  final client = http.Client();
  final StringBuffer outputBuffer = StringBuffer();
  final dateTime =
      DateTime.now().toIso8601String().replaceAll(':', '-').split('.')[0];

  // Define output directories
  final baseOutputDir = 'lib/row_row_row';
  final reportDir = Directory('$baseOutputDir/db_schema_report');
  final tablesDir = Directory('$baseOutputDir/tables');
  final enumsDir = Directory('$baseOutputDir/enums'); // New directory for enums

  // Ensure directories exist
  if (!await reportDir.exists()) {
    await reportDir.create(recursive: true);
  }
  if (!await tablesDir.exists()) {
    await tablesDir.create(recursive: true);
  }
  if (!await enumsDir.exists()) {
    await enumsDir.create(recursive: true);
  }

  final outputFile = File('${reportDir.path}/db_schema_$dateTime.txt');
  bool generationSuccessful = false;
  final Map<String, List<String>> enumsToGenerate =
      {}; // Store enums to generate {EnumName: [values]}
  final Map<String, String> columnToEnumMapping =
      {}; // Maps "tableName.columnName" to enum type name

  try {
    outputBuffer.writeln('DATABASE SCHEMA EXPORT (from OpenAPI Spec)');
    outputBuffer.writeln('Exported at: ${DateTime.now()}');
    outputBuffer.writeln('Supabase URL: $supabaseUrl');
    outputBuffer.writeln('Project ID: $projectId');
    outputBuffer.writeln('----------------------------------------\n');

    // Clean output directories before generating new files, but only if clean flag is set
    if (clean) {
      print('Cleaning output directories...');
      await _cleanDirectory(tablesDir);
      await _cleanDirectory(enumsDir);

      print('Done cleaning. Ready to generate new files.');
      outputBuffer.writeln('Cleaned output directories before generation.\n');
    } else {
      print(
        'Skipping cleanup. Use --clean to delete existing files before generation.',
      );
    }

    print('Fetching OpenAPI specification from API root...');
    outputBuffer.writeln(
      'Fetching OpenAPI specification from $supabaseUrl/rest/v1/ ...',
    );

    final response = await client.get(
      Uri.parse('$supabaseUrl/rest/v1/'),
      headers: {
        'apikey': serviceRoleKey,
        'Authorization': 'Bearer $serviceRoleKey',
      },
    );

    if (response.statusCode == 200) {
      try {
        final openApiSpec = jsonDecode(response.body);
        outputBuffer.writeln('Successfully fetched OpenAPI spec.');
        if (openApiSpec is Map && openApiSpec.containsKey('definitions')) {
          final definitions =
              openApiSpec['definitions'] as Map<String, dynamic>;

          if (definitions.isNotEmpty) {
            outputBuffer.writeln('\nTABLES AND VIEWS (from OpenAPI spec):');
            outputBuffer.writeln('--------------------------------------\n');

            int tableCount = 0;

            // First pass: Scan for all enums to build type mappings
            definitions.forEach((tableName, definition) {
              if (tableName.startsWith('pg_') ||
                  tableName == 'swagger' ||
                  tableName == 'info') {
                return; // Skip system tables/views
              }

              if (definition is Map && definition.containsKey('properties')) {
                final properties =
                    definition['properties'] as Map<String, dynamic>;

                // Check for enum type columns
                properties.forEach((columnName, property) {
                  if (property is Map<String, dynamic> &&
                      property.containsKey('enum') &&
                      property['enum'] is List) {
                    final enumValues =
                        (property['enum'] as List).cast<String>();

                    // Try to get the actual enum type name from various possible sources
                    String typeNameSource = 'derived';
                    String typeName;

                    // Check for explicit enum type information
                    if (property.containsKey('format')) {
                      // remove "public." prefix if present
                      typeName = property['format'].toString().replaceFirst(
                            'public.',
                            '',
                          );
                      typeNameSource = 'format';
                    } else if (property.containsKey('title')) {
                      typeName = property['title'] as String;
                      typeNameSource = 'title';
                    } else if (property.containsKey('x-enum-name')) {
                      typeName = property['x-enum-name'] as String;
                      typeNameSource = 'x-enum-name';
                    } else if (property.containsKey('x-pg-enum-name')) {
                      typeName = property['x-pg-enum-name'] as String;
                      typeNameSource = 'x-pg-enum-name';
                    } else if (property.containsKey('type') &&
                        property['type'] != 'string') {
                      // Use the type if it's not just 'string' (which is generic)
                      typeName = property['type'] as String;
                      typeNameSource = 'type';
                    } else {
                      // If no explicit type name, derive it from column name
                      typeName = '${columnName.toPascalCase()}Type';
                      typeNameSource = 'column name';
                    }

                    // Create a consistent Dart enum name
                    final enumName = '${typeName.toPascalCase()}Enum';

                    // Store mapping from column to enum type
                    columnToEnumMapping['$tableName.$columnName'] = enumName;

                    // Store for generation, avoid duplicates by checking key
                    if (!enumsToGenerate.containsKey(enumName)) {
                      enumsToGenerate[enumName] = enumValues;

                      print(
                        '• Detected enum type: $enumName (source: $typeNameSource)',
                      );
                      outputBuffer.writeln(
                        'ENUM TYPE: $enumName (source: $typeNameSource)',
                      );
                      outputBuffer.writeln(
                        '  Values: ${enumValues.join(', ')}',
                      );
                      outputBuffer.writeln('');
                    }
                  }
                });
              }
            });

            // Second pass: Generate row classes with proper enum typing
            definitions.forEach((tableName, definition) {
              if (tableName.startsWith('pg_') ||
                  tableName == 'swagger' ||
                  tableName == 'info') {
                return; // Skip system tables/views
              }
              tableCount++;

              if (definition is Map && definition.containsKey('properties')) {
                final properties =
                    definition['properties'] as Map<String, dynamic>;
                final required = definition['required'] as List<dynamic>? ?? [];
                print('• $tableName');
                outputBuffer.writeln('TABLE/VIEW: $tableName');
                outputBuffer.writeln('COLUMNS:');

                // Build map of column names to enum types for this table
                final tableEnumMap = <String, String>{};
                properties.forEach((columnName, property) {
                  if (property is Map<String, dynamic>) {
                    final type =
                        property['format'] ?? property['type'] ?? 'unknown';
                    final isNullable = !required.contains(columnName);
                    final description =
                        property['description'] as String? ?? '';
                    String foreignKeyInfo = '';
                    final fkMatch = RegExp(
                      r"<fk table='(.+?)' column='(.+?)'/>",
                    ).firstMatch(description);
                    if (fkMatch != null) {
                      foreignKeyInfo =
                          ' → ${fkMatch.group(1)}.${fkMatch.group(2)}';
                    }

                    String typeInfo = type;
                    // Check if this column defines an enum
                    if (property.containsKey('enum') &&
                        property['enum'] is List) {
                      // Look up the enum name we previously determined
                      final key = '$tableName.$columnName';
                      if (columnToEnumMapping.containsKey(key)) {
                        final enumName = columnToEnumMapping[key]!;
                        typeInfo = 'enum $enumName'; // Mark as enum in report
                        tableEnumMap[columnName] =
                            enumName; // Store for _mapType calls
                      }
                    }

                    outputBuffer.writeln(
                      '  • $columnName ($typeInfo, ${isNullable ? 'NULL' : 'NOT NULL'})$foreignKeyInfo',
                    );
                  }
                });
                outputBuffer.writeln('');

                // Make sure definition is processed correctly when passed
                print('\nProcessing: $tableName');
                print('Definition type: ${definition.runtimeType}');
                print('Definition keys: ${(definition).keys.join(', ')}');

                try {
                  // Check if this is a view to add appropriate comment in the report
                  final Map<String, dynamic> typedDefinition = {};

                  // Copy all keys from original definition to ensure proper types
                  (definition).forEach((key, value) {
                    typedDefinition[key.toString()] = value;
                  });

                  // Ensure properties is properly added
                  typedDefinition['properties'] = properties;
                  typedDefinition['required'] = required;
                  typedDefinition['name'] = tableName;

                  final isView = _isView(tableName, typedDefinition);
                  if (isView) {
                    outputBuffer.writeln(
                      '  (This is a database view, CRUD operations not available)',
                    );
                    print('⚠️ $tableName detected as a view in main function');
                  } else {
                    print('✅ $tableName detected as a table in main function');
                  }

                  // Generate the row class, passing the complete definition with proper types
                  final rowClassContent = _generateRowClass(
                    tableName,
                    properties,
                    required,
                    enumsToGenerate,
                    tableEnumMap, // Pass column->enum mapping for this table
                    typedDefinition, // Pass the properly typed definition
                  );
                  // Use snake_case for file name convention
                  final rowFile = File(
                    '${tablesDir.path}/${tableName.toSnakeCase()}.row.dart',
                  );
                  rowFile.writeAsStringSync(rowClassContent);
                  print('  -> Generated ${rowFile.path}');
                  outputBuffer.writeln('  -> Generated ${rowFile.path}');
                } catch (e, s) {
                  final errorMsg =
                      'Error generating row file for $tableName: $e\n$s';
                  print('  -> $errorMsg');
                  outputBuffer.writeln('  -> $errorMsg');
                }
              }
            });

            // --- Generate Enum Files ---
            if (enumsToGenerate.isNotEmpty) {
              print('\nGenerating enum files in ${enumsDir.path}...');
              outputBuffer.writeln('\nGENERATED ENUMS:');
              outputBuffer.writeln('----------------');
              enumsToGenerate.forEach((enumName, values) {
                try {
                  final enumFileContent = _generateEnumFile(enumName, values);
                  // Strip 'Enum' suffix if present to avoid redundancy in file naming
                  final enumBaseName = enumName.endsWith('Enum')
                      ? enumName.substring(0, enumName.length - 4)
                      : enumName;

                  // Use snake_case for file name convention
                  final enumFile = File(
                    '${enumsDir.path}/${enumBaseName.toSnakeCase()}.enum.dart',
                  );
                  enumFile.writeAsStringSync(enumFileContent);
                  print('  -> Generated ${enumFile.path}');
                  outputBuffer.writeln('  ENUM: $enumName -> ${enumFile.path}');
                  outputBuffer.writeln('    Values: ${values.join(', ')}');
                } catch (e, s) {
                  final errorMsg =
                      'Error generating enum file for $enumName: $e\n$s';
                  print('  -> $errorMsg');
                  outputBuffer.writeln('  -> Error for $enumName: $e');
                }
              });
              outputBuffer.writeln();
            }
            // --- End Enum Generation ---

            if (tableCount > 0) {
              print(
                '\nSuccess: Processed $tableCount user definitions (tables/views) in OpenAPI spec.',
              );
              outputBuffer.writeln(
                'Success: Processed $tableCount user definitions in OpenAPI spec.',
              );
              generationSuccessful = true;
            } else {
              print(
                '\nWarning: OpenAPI spec definitions found, but no user tables/views identified after filtering.',
              );
              outputBuffer.writeln(
                'Warning: OpenAPI spec definitions found, but no user tables/views identified after filtering.',
              );
            }
          } else {
            print(
              '\nWarning: OpenAPI spec found, but no table/view definitions.',
            );
            outputBuffer.writeln(
              'Warning: OpenAPI spec found, but no table/view definitions.',
            );
          }
        } else {
          print(
            '\nError: Invalid OpenAPI spec format (missing "definitions").',
          );
          outputBuffer.writeln(
            'Error: Invalid OpenAPI spec format (missing "definitions").\nResponse Body: ${response.body}',
          );
        }
      } catch (e, s) {
        final errorMsg = 'Error: Failed to parse OpenAPI spec: $e\n$s';
        print(errorMsg);
        outputBuffer.writeln('$errorMsg\nResponse Body: ${response.body}');
      }
    } else {
      final errorMsg =
          'Error: Could not fetch OpenAPI spec. Status: ${response.statusCode}';
      print(errorMsg);
      outputBuffer.writeln(errorMsg);
      print(
        '\nPlease check the .env file for correct SUPABASE_URL and SERVICE_ROLE.',
      );
      print(
        '\nEnsure the base REST API endpoint ($supabaseUrl/rest/v1/) is accessible.',
      );
    }

    await outputFile.writeAsString(outputBuffer.toString());
    print('\nSchema report written to ${outputFile.path}');

    // Formatting applies to both tables and enums directories now
    if (generationSuccessful && formatCode) {
      print('\nFormatting generated files in $baseOutputDir...');
      try {
        // Format the base generated directory recursively
        final result = await Process.run('dart', ['format', baseOutputDir]);
        if (result.exitCode == 0) {
          print('Formatting successful.');
        } else {
          print('Error during formatting (exit code: ${result.exitCode}):');
          print(result.stderr);
        }
      } catch (e) {
        print('Error running dart format: $e');
        print('Please ensure the Dart SDK is in your PATH.');
      }
    } else if (generationSuccessful && !formatCode) {
      print('\nSkipping code formatting. Use --dart-format to enable.');
    }
  } finally {
    client.close();
  }
}
